#+TITLE: S3 back end
#+PROPERTY: comments org
#+SETUPFILE: ../../docs/theme.setup
# -*- mode: org -*-

  The "file" produced by the text back end is a directory with one
  file per group.

  When the file is open, it is locked by the current process. No other
  process can read/write the same file. This guarantees that the
  representation in memory is consistent with the file and avoid
  re-reading the file before writing.
  To lock the file, we lock the =.lock= file which is present in the
  directory.

  The file is written when closed, or when the flush function is called.

* Constant file prefixes (not used by the generator)               :noexport:

  #+begin_src emacs-lisp
 (setq-local org-babel-default-header-args:c '((:comments . "both")))
  org-babel-default-header-args:c
#+end_src

#+RESULTS:
: ((:comments . both))

# Local Variables:
# eval: (setq-local org-babel-default-header-args:Python '((:session . "foo")))
# End:


  #+NAME:header
  #+begin_src c
/* This file was generated from the trexio.org org-mode file.
   To generate it, open trexio.org in Emacs and execute
   M-x org-babel-tangle
*/



  #+end_src

  #+begin_src c :tangle prefix_s3.h :noweb yes
#ifndef TREXIO_S3_H
#define TREXIO_S3_H

#include <trexio_s3_rust.h>

#include "trexio.h"
#include "trexio_private.h"
#include "trexio_s.h"
#include <errno.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <stdbool.h>
#include <trexio_text.h>
#include <trexio_s3.h>

typedef struct trexio_s3_client trexio_s3_client;
  #+end_src

  #+begin_src c :tangle prefix_s3.c :noweb yes
/* This file was generated from the trexio.org org-mode file.
   To generate it, open trexio.org in Emacs and execute
   M-x org-babel-tangle
*/


#include "trexio_s3.h"

  #+end_src

* Template for group-related structures in text back end

    #+begin_src c :tangle struct_s3_group_dset.h
typedef struct $group$_s {
  $group_num_dtype_double$ $group_num$;
  $group_dset_dtype$*  $group_dset$;
  uint64_t dims_$group_dset$[16];
  uint64_t len_$group_str$;
  uint32_t rank_$group_dset$;
  uint32_t to_flush;
  bool $group_num$_isSet;
  char*    $group_str$;
  char     file_name[TREXIO_MAX_FILENAME_LENGTH];
  trexio_s3_client* client; //pointeur vers la connexion S3
} $group$_t;
    #+end_src


* Template for general structure in text back end

   Polymorphism of the ~trexio_t~ type is handled by ensuring that the
   corresponding types for all back ends can be safely casted to
   ~trexio_t~. This is done by making the back-end structs start with
   ~trexio_t parent~ attribute:

    #+begin_src c :tangle struct_s3_group.h
typedef struct trexio_s3_s {
  trexio_t   parent ;
  $group$_t* $group$;
//  int        lock_file;
  trexio_s3_client* client; //Pointeur vers la connexion S3 NOZHA SAFI
  char s3_bucket_name[TREXIO_MAX_FILENAME_LENGTH]; //Nom du bucket S3
} trexio_s3_t;
    #+end_src

* Initialize function (constant part)

    #+begin_src c :tangle basic_s3.h :exports none
trexio_exit_code trexio_s3_init(trexio_t* const file);
trexio_exit_code trexio_s3_inquire(const char* file_name);
trexio_exit_code trexio_s3_deinit(trexio_t* const file);
trexio_exit_code trexio_s3_flush(trexio_t* const file);
    #+end_src

    #+begin_src c :tangle basic_s3.c
trexio_exit_code
trexio_s3_inquire (const char* file_name)
{
 /* Check if the file with "file_name" exists and that it is a directory */
  /* Check if a logical directory (prefix) exists on S3 by checking for any object under that prefix.*/
      if(file_name==NULL){
        return TREXIO_INVALID_ARG_1;
      }
      trexio_s3_client* client=s3_connect();
      if(client==NULL){
        return TREXIO_FAILURE; //Connexion echec
      }
      int file_exists = s3_file_exists(client, file_name, strlen(file_name));
      s3_disconnect(client);
      return file_exists == 0 ? TREXIO_SUCCESS : TREXIO_FAILURE;

}
    #+end_src

    #+begin_src c :tangle basic_s3.c
trexio_exit_code
trexio_s3_init (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  trexio_s3_t* const f = (trexio_s3_t*) file;

  /* Put all pointers to NULL but leave parent untouched */
  memset(&(f->parent)+1,0,sizeof(trexio_s3_t)-sizeof(trexio_t));
 f->client=s3_connect();
  if(f->client==NULL) return TREXIO_FAILURE;

  const char* file_name = file->file_name;
  /* Check if the file (prefix) exists in the S3 bucket */
  int exist;
  exist = s3_file_exists(f->client, file_name, strlen(file_name));

 /* If file does not exist - create it in write mode */
  if(!exist && file->mode == 'r') {
        s3_disconnect(f->client);
        return TREXIO_OPEN_ERROR;
     }
//si le mode est écriture, on peut continuer (création différée)
  return TREXIO_SUCCESS;
  fprintf(stderr, "[TREXIO_S3]%s:initialisation\n", __func__);
}
    #+end_src

    #+begin_src c :tangle basic_s3.c
trexio_exit_code trexio_s3_lock(trexio_t* const file) {
  if (file == NULL) return TREXIO_INVALID_ARG_1;

  return TREXIO_SUCCESS;

}
    #+end_src

    #+begin_src c :tangle basic_s3.c
trexio_exit_code
trexio_s3_unlock (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  return TREXIO_SUCCESS;

}
    #+end_src

* Deinitialize function (templated part)

    #+begin_src c :tangle basic_s3_group.c
trexio_exit_code
trexio_s3_deinit (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

 trexio_s3_t* const f=(trexio_s3_t*)file;

  trexio_exit_code rc=TREXIO_SUCCESS;

  /* Error handling for this call is added by the generator */
  rc = trexio_s3_free_$group$(f);
  if(rc!=TREXIO_SUCCESS){
        s3_disconnect(f->client);
        f->client =NULL;
        return rc;
   }
   s3_disconnect(f->client);
   f->client=NULL;

   return TREXIO_SUCCESS;
}
    #+end_src

* Flush function (templated part)

    #+begin_src c :tangle basic_s3_group.c
trexio_exit_code
trexio_s3_flush (trexio_t* const file)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  trexio_s3_t* f = (trexio_s3_t*) file;
  trexio_exit_code rc;
  rc = trexio_s3_flush_$group$(f);   //Cette fonction va appeler s3_put()
  if (rc != TREXIO_SUCCESS) return rc;
  printf("rc:%d (%s)\n",rc, trexio_string_of_error(rc));

  return TREXIO_SUCCESS;
}
    #+end_src

* Template for text read a group

    #+begin_src c :tangle read_group_s3.h :exports none
$group$_t* trexio_s3_read_$group$(trexio_s3_t* const file);
    #+end_src

    #+begin_src c :tangle read_group_s3.c
$group$_t*
trexio_s3_read_$group$ (trexio_s3_t* const file)
{

  if (file == NULL) return NULL;

  /* If the data structure exists, return it */
  if (file->$group$ != NULL) {
    return file->$group$;
  }

  /* Allocate the data structure */
  $group$_t* $group$ = MALLOC($group$_t);
  if ($group$ == NULL) return NULL;

  memset($group$,0,sizeof($group$_t));

  /* Build the file name */
  const char* $group$_file_name = "/$group$.txt";

  strncpy ($group$->file_name, file->parent.file_name, TREXIO_MAX_FILENAME_LENGTH);
  $group$->file_name[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  strncat ($group$->file_name, $group$_file_name,
           TREXIO_MAX_FILENAME_LENGTH-strlen($group$_file_name)-1);

  if ($group$->file_name[TREXIO_MAX_FILENAME_LENGTH-1] != '\0') {
    FREE($group$);
    return NULL;
  }

  /* If the file exists, read it */
 /* Find size of file to allocate the max size of the string buffer */

    size_t sz=s3_size(file->client, $group$->file_name, strlen($group$->file_name));
    if(sz == 0){
        FREE($group$);
        return NULL;
    }

    char* f=CALLOC(sz+1, char);  //+1 pour null-terminate si texte
    if(f==NULL){
        FREE($group$);
        return NULL;

    int rc=s3_get(file->client, $group$->file_name, strlen($group$->file_name), f, sz);
    if(rc != 0){
        FREE(f);
        FREE($group$);
        return NULL;
    }

    sz = (sz < 1024) ? (1024) : (sz);
    char* buffer = CALLOC(sz, char);
    if (buffer == NULL) {
      FREE(f);
      FREE($group$);
      return NULL;
    }

   // int rc = 0;
  //  (void) rc;  // Avoid unused variable;
  //  trexio_exit_code rc_free = TREXIO_FAILURE;
   // (void) rc_free;  // Avoid unused variable;

    /* workaround for the case of missing blocks in the file */
    // START REPEAT GROUP_DSET_ALL
    uint64_t size_$group_dset$ = 0;
    // END REPEAT GROUP_DSET_ALL
    
    char* line =f;
    while(sscanf(line, "%1023s", buffer) != EOF) {

      if (strcmp(buffer, "EXIT") == 0) {
        break;
      // START REPEAT GROUP_DSET_ALL
      } else if (strcmp(buffer, "rank_$group_dset$") == 0) {
          line+=strcspn(line,"\n")+1;
        rc = sscanf(line, "%u", &($group$->rank_$group_dset$));
        if (rc != 1) {
          trexio_s3_free_read_$group$(buffer, f, file, $group$);
          return NULL;
        }

        if ($group$->rank_$group_dset$ != 0) size_$group_dset$ = 1UL;

        for (uint32_t i=0; i<$group$->rank_$group_dset$; ++i){
          line+=strcspn(line,"\n")+1;
          uint32_t j=0;
          rc = sscanf(line, "%1023s %u", buffer, &j);
          if ((rc != 2) || (strcmp(buffer, "dims_$group_dset$") != 0) || (j!=i)) {
            trexio_s3_free_read_$group$(buffer, f, file, $group$);
            return NULL;
          }
          line+=strcspn(line,"\n")+1;
          rc = sscanf(line, "%" SCNu64 "\n", &($group$->dims_$group_dset$[i]));
          assert(!(rc != 1));
          if (rc != 1) {
            trexio_s3_free_read_$group$(buffer, f, file, $group$);
            return NULL;
          }

          size_$group_dset$ *= $group$->dims_$group_dset$[i];
        }
      // END REPEAT GROUP_DSET_ALL
      // START REPEAT GROUP_DSET_NUM
      } else if (strcmp(buffer, "$group_dset$") == 0) {

        /* Allocate arrays */
        $group$->$group_dset$ = CALLOC(size_$group_dset$, $group_dset_dtype$);
        if ($group$->$group_dset$ == NULL) {
          trexio_s3_free_read_$group$(buffer, f, file, $group$);
          return NULL;
        }

        for (uint64_t i=0 ; i<size_$group_dset$ ; ++i) {
          line+=strcspn(line,"\n")+1;
          rc = sscanf(line, "%$group_dset_format_scanf$", &($group$->$group_dset$[i]));
          if (rc != 1) {
            trexio_s3_free_read_$group$(buffer, f, file, $group$);
            return NULL;
          }
        }

      // END REPEAT GROUP_DSET_NUM
      // START REPEAT GROUP_DSET_STR
      } else if (strcmp(buffer, "$group_dset$") == 0) {
          line+=strcspn(line,"\n")+1;
          if (size_$group_dset$ != 0) {
             /* Allocate arrays */
               $group$->$group_dset$ = CALLOC(size_$group_dset$, $group_dset_dtype$);
               if ($group$->$group_dset$ == NULL) {
                   trexio_s3_free_read_$group$(buffer, f, file, $group$);
                   return NULL;
               }   

          /* WARNING: this tmp array allows to avoid allocation of space for each element of array of string
           ,* BUT it's size has to be number_of_str*max_len_str where max_len_str is somewhat arbitrary, e.g. 32.
           ,*/
             char* tmp_$group_dset$;
             tmp_$group_dset$ = CALLOC(size_$group_dset$*32, char);

             for (uint64_t i=0 ; i<size_$group_dset$ ; ++i) {
                  $group$->$group_dset$[i] = tmp_$group_dset$;
/* conventional fcanf with "%s" only return the string before the first space character
,* to read string with spaces use "%[^\n]" possible with space before or after, i.e. " %[^\n]"
,*/
            rc = sscanf(line, " %1023[^\n]", buffer);
            if (rc != 1) {
              trexio_s3_free_read_$group$(buffer, f, file, $group$);
              return NULL;
            }

            size_t tmp_$group_dset$_len = strlen(buffer);
            strncpy(tmp_$group_dset$, buffer, 32);
            tmp_$group_dset$[31] = '\0';
            tmp_$group_dset$ += tmp_$group_dset$_len + 1;
          }
        }

      // END REPEAT GROUP_DSET_STR
      // START REPEAT GROUP_NUM
      } else if (strcmp(buffer, "$group_num$_isSet") == 0) {
        line+=strcspn(line,"\n")+1;
        unsigned int $group_num$_isSet;
        /* additional parameter $group_num$_isSet is needed to suppress warning when fscanf into bool variable using %u or %d */
        rc = sscanf(line, "%u", &($group_num$_isSet));
        $group$->$group_num$_isSet = (bool) $group_num$_isSet;
        if (rc != 1) {
          trexio_s3_free_read_$group$(buffer, f, file, $group$);
          return NULL;
        }

        if ($group$->$group_num$_isSet == true) {
          line+=strcspn(line,"\n")+1;
          rc = sscanf(line, "%1023s", buffer);
          if ((rc != 1) || (strcmp(buffer, "$group_num$") != 0)) {
            trexio_s3_free_read_$group$(buffer, f, file, $group$);
            return NULL;
          }
          line+=strcspn(line,"\n")+1;
          rc = sscanf(line, "%$group_num_format_scanf$", &($group$->$group_num$));
          if (rc != 1) {
            trexio_s3_free_read_$group$(buffer, f, file, $group$);
            return NULL;
          }

        }

      // END REPEAT GROUP_NUM
      // START REPEAT GROUP_ATTR_STR
      } else if (strcmp(buffer, "len_$group_str$") == 0) {
          line+=strcspn(line,"\n")+1;
        rc = sscanf(line, "%" SCNu64 "", &($group$->len_$group_str$));
        if (rc != 1) {
          trexio_s3_free_read_$group$(buffer, f, file, $group$);
          return NULL;
        }
          line+=strcspn(line,"\n")+1;
        rc = sscanf(line, "%1023s", buffer);
        if ((rc != 1) || (strcmp(buffer, "$group_str$") != 0)) {
          trexio_s3_free_read_$group$(buffer, f, file, $group$);
          return NULL;
        }

        if ($group$->len_$group_str$ != 0) {

          $group$->$group_str$ = CALLOC($group$->len_$group_str$, char);
          if ($group$->$group_str$ == NULL) {
            trexio_s3_free_read_$group$(buffer, f, file, $group$);
            return NULL;
          }
          line+=strcspn(line,"\n")+1;
          rc = sscanf(line, " %1023[^\n]", buffer);
          if (rc != 1) {
            trexio_s3_free_read_$group$(buffer, f, file, $group$);
            return NULL;
          }
          /* Safer string conversion to avoid buffer overflow in fscanf */
          strncpy($group$->$group_str$, buffer, $group$->len_$group_str$);
          $group$->$group_str$[$group$->len_$group_str$-1] = '\0';

        }
      // END REPEAT GROUP_ATTR_STR
      } else {
        line+=strcspn(line,"\n")+1;
        continue;
      }
      line+=strcspn(line,"\n")+1;
    }

    FREE(buffer);
    FREE(f);
  }

  file->$group$ = $group$;
  return $group$;
}
   #+end_src

* Template for text has a group

    #+begin_src c :tangle hrw_group_s3.h :exports none
trexio_exit_code trexio_s3_has_$group$(trexio_t* const file);
    #+end_src

    #+begin_src c :tangle has_group_s3.c
trexio_exit_code
trexio_s3_has_$group$ (trexio_t* const file)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  trexio_s3_t* s3_file=(trexio_s3_t*)file;
  /* Flush the group to make sure the group.txt file is created */
  if (file->mode != 'r') {
    trexio_exit_code rc = trexio_s3_flush_$group$(s3_file);
    if (rc != TREXIO_SUCCESS) return TREXIO_FAILURE;
  }

  /* Build the file name */
  char $group$_full_path[TREXIO_MAX_FILENAME_LENGTH];

  const char* $group$_file_name = "/$group$.txt";

  strncpy ($group$_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  $group$_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  strncat ($group$_full_path, $group$_file_name,
           TREXIO_MAX_FILENAME_LENGTH-strlen($group$_file_name));

  if ($group$_full_path[TREXIO_MAX_FILENAME_LENGTH-1] != '\0') return TREXIO_FAILURE;

  int file_exists;
  file_exists = s3_file_exists(s3_file->client, $group$_full_path, strlen($group$_full_path));

  if (file_exists==0) {
    return TREXIO_SUCCESS;
  } else {
    return TREXIO_HAS_NOT;
  }
}
   #+end_src

* Template for text flush a group

    #+begin_src c :tangle flush_group_s3.h :exports none
trexio_exit_code trexio_s3_flush_$group$(trexio_s3_t* const file);
    #+end_src

    #+begin_src c :tangle flush_group_s3.c
trexio_exit_code
trexio_s3_flush_$group$ (trexio_s3_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  if (file->parent.mode == 'r') return TREXIO_READONLY;

  $group$_t* $group$ = file->$group$;
  if ($group$ == NULL) return TREXIO_SUCCESS;

  if ($group$->to_flush == 0) return TREXIO_SUCCESS;

  assert (file->parent.mode == 'w' || file->parent.mode == 'u');

//=== Construction du chemin S3 ===
  const char* suffix="/$group$.txt";
 if(strlen(file->parent.file_name)+strlen(suffix)>=TREXIO_MAX_FILENAME_LENGTH) return TREXIO_FAILURE;

  char s3_path[TREXIO_MAX_FILENAME_LENGTH];

  strncpy(s3_path, file->parent.file_name, TREXIO_MAX_FILENAME_LENGTH);

  s3_path[TREXIO_MAX_FILENAME_LENGTH - 1]='\0';
  strncat(s3_path, suffix, TREXIO_MAX_FILENAME_LENGTH - strlen(s3_path) - 1);

  if(s3_path[TREXIO_MAX_FILENAME_LENGTH -1]!='\0') return TREXIO_FAILURE;
//=== Initialisation du buffer dynamique ===
  size_t buffer_init=4096;
  size_t buffer_size=0;
  char* buffer = malloc(buffer_init);
  if(!buffer) return TREXIO_FAILURE;

// === Ligne de sortie temporaire ===
  char line[1024];
  size_t line_len;

//=== Ecriture des dimension

  /* Write the dimensioning variables */
  // START REPEAT GROUP_DSET_ALL
  snprintf(line, sizeof(line), "rank_$group_dset$ %u\n", $group$->rank_$group_dset$);

  line_len=strlen(line);

  // === Réallocation si nécessaire ===
  while(buffer_size + line_len >= buffer_init){
        buffer_init *=2;
        char* new_buffer=realloc(buffer, buffer_init*sizeof(char));
        if(!new_buffer){
                FREE(buffer);
                return TREXIO_FAILURE;
        }
        buffer=new_buffer;
  }
  memcpy(buffer+buffer_size, line, line_len);
  buffer_size += line_len;

  // workaround for the case of missing blocks in the file
  uint64_t size_$group_dset$ = 0;
  if ($group$->rank_$group_dset$ != 0) size_$group_dset$ = 1;

  for (unsigned int i=0; i<$group$->rank_$group_dset$; ++i){
        snprintf(line, sizeof(line), "dims_$group_dset$ %u %" PRIu64 "\n", i, $group$->dims_$group_dset$[i]);
        line_len=strlen(line);
       // === Réallocation si nécessaire ===
        while(buffer_size + line_len >= buffer_init){
                buffer_init *=2;
                char* new_buffer=realloc(buffer, buffer_init*sizeof(char));
                if(!new_buffer){
                        FREE(buffer);
                        return TREXIO_FAILURE;
                }
                buffer=new_buffer;
        }
        memcpy(buffer+buffer_size, line, line_len);
        buffer_size += line_len;
        size_$group_dset$ *= $group$->dims_$group_dset$[i];
  }
  // END REPEAT GROUP_DSET_ALL

  // START REPEAT GROUP_NUM
  snprintf(line, sizeof(line), "$group_num$_isSet %u \n", $group$->$group_num$_isSet);
  line_len = strlen(line);
 // === Réallocation si nécessaire ===
  while(buffer_size + line_len >= buffer_init){
        buffer_init *=2;
        char* new_buffer=realloc(buffer, buffer_init*sizeof(char));
        if(!new_buffer){
                FREE(buffer);
                return TREXIO_FAILURE;
        }
        buffer=new_buffer;
  }
  memcpy(buffer+buffer_size, line, line_len);
  buffer_size += line_len;

  if($group$->$group_num$_isSet==true){
        snprintf(line, sizeof(line), "$group_num$ %$group_num_format_printf$\n", $group$->$group_num$);
        line_len = strlen(line);

        // === Réallocation si nécessaire ===
        while(buffer_size + line_len >= buffer_init){
                buffer_init *=2;
               char* new_buffer=realloc(buffer, buffer_init*sizeof(char));
                if(!new_buffer){
                        FREE(buffer);
                        return TREXIO_FAILURE;
                }
                buffer=new_buffer;
        }
        memcpy(buffer+buffer_size, line, line_len);
         buffer_size += line_len;
  }
  // END REPEAT GROUP_NUM

  // START REPEAT GROUP_ATTR_STR
  snprintf(line, sizeof(line), "len_$group_str$ %" PRIu64 "\n", $group$->len_$group_str$);
  line_len = strlen(line);

  // === Réallocation si nécessaire ===
  while(buffer_size + line_len >= buffer_init){
        buffer_init *=2;
       char* new_buffer=realloc(buffer, buffer_init*sizeof(char));
        if(!new_buffer){
                FREE(buffer);
                return TREXIO_FAILURE;
        }
        buffer=new_buffer;
  }
  memcpy(buffer+buffer_size, line, line_len);
  buffer_size += line_len;

  snprintf(line, sizeof(line), "$group_str$\n");
  line_len = strlen(line);

  // === Réallocation si nécessaire ===
  while(buffer_size + line_len >= buffer_init){
       buffer_init *=2;
        char* new_buffer=realloc(buffer, buffer_init*sizeof(char));
        if(!new_buffer){
                FREE(buffer);
                return TREXIO_FAILURE;
        }
        buffer=new_buffer;
  }
  memcpy(buffer+buffer_size, line, line_len);
  buffer_size += line_len;

  if($group$->len_$group_str$ !=0){
        snprintf(line, sizeof(line), "%s\n", $group$->$group_str$);
        line_len = strlen(line);

        // === Réallocation si nécessaire ===
        while(buffer_size + line_len >= buffer_init){
                buffer_init *=2;
                char* new_buffer=realloc(buffer, buffer_init*sizeof(char));
               if(!new_buffer){
                        FREE(buffer);
                        return TREXIO_FAILURE;
                }
                buffer=new_buffer;
        }
        memcpy(buffer+buffer_size, line, line_len);
        buffer_size += line_len;
  }
  // END REPEAT GROUP_ATTR_STR



  /* Write arrays */
  // START REPEAT GROUP_DSET_ALL

  snprintf(line, sizeof(line), "$group_dset$\n");
  for (uint64_t i=0 ; i<size_$group_dset$ ; ++i) {
    snprintf(line, sizeof(line), "%$group_dset_format_printf$\n", $group$->$group_dset$[i]);
   line_len=strlen(line);
    // === Réallocation si nécessaire ===
    while(buffer_size + line_len >= buffer_init){
        buffer_init *=2;
        char* new_buffer=realloc(buffer, buffer_init*sizeof(char));
        if(!new_buffer){
                FREE(buffer);
                return TREXIO_FAILURE;
        }
        buffer=new_buffer;
    }
        memcpy(buffer+buffer_size, line, line_len);
        buffer_size += line_len;
  }
  // END REPEAT GROUP_DSET_ALL
//=== Fin du fichier ==
  snprintf(line, sizeof(line), "EXIT\n");
  line_len=strlen(line);
        // === Réallocation si nécessaire ===
        while(buffer_size + line_len >= buffer_init){
                buffer_init *=2;
                char* new_buffer=realloc(buffer, buffer_init*sizeof(char));
                if(!new_buffer){
                        FREE(buffer);
                        return TREXIO_FAILURE;
                }
                buffer=new_buffer;
        }
        memcpy(buffer+buffer_size, line, line_len);
        buffer_size += line_len;

//=== Upload final vers S3 ===
  printf("s3_path:%s, buffer:%s, buffer_size:%ld\n",s3_path, buffer, buffer_size);
  int rc=s3_put(file->client, s3_path, strlen(s3_path), buffer, buffer_size);
  FREE(buffer);
 if(rc!=0) return TREXIO_FAILURE;
  $group$->to_flush = 0;
  return TREXIO_SUCCESS;

}
   #+end_src

* Template for text free memory

     Memory is allocated when reading. The following function frees memory.

    #+begin_src c :tangle free_group_s3.h :exports none
trexio_exit_code trexio_s3_free_$group$(trexio_s3_t* const file);
    #+end_src

    #+begin_src c :tangle free_group_s3.c
trexio_exit_code
trexio_s3_free_$group$ (trexio_s3_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  if (file->parent.mode != 'r') {
    trexio_exit_code rc = trexio_s3_flush_$group$(file);
    if (rc != TREXIO_SUCCESS) return TREXIO_FAILURE;
  }

  $group$_t* $group$ = file->$group$;
  if ($group$ == NULL) return TREXIO_SUCCESS;

  // START REPEAT GROUP_DSET_NUM
  if ($group$->$group_dset$ != NULL){
	 FREE ($group$->$group_dset$);
	$group$->$group_dset$=NULL;
  }
  // END REPEAT GROUP_DSET_NUM

  // START REPEAT GROUP_DSET_STR
    if ($group$->$group_dset$ != NULL) {
    	if ($group$->rank_$group_dset$ != 0 && $group$->$group_dset$[0] != NULL){
		 FREE ($group$->$group_dset$[0]);
     	}
    FREE ($group$->$group_dset$);
    $group$->$group_dset$ =NULL;
  }

  // END REPEAT GROUP_DSET_STR

  // START REPEAT GROUP_ATTR_STR
  if ($group$->$group_str$ != NULL){
	 FREE ($group$->$group_str$);
	 $group$->$group_str$=NULL;
  }
  // END REPEAT GROUP_ATTR_STR

  FREE ($group$);
  file->$group$ = NULL;

  return TREXIO_SUCCESS;

}
    #+end_src

  This function is called upon the non-successful exit from the ~trexio_s3_read_group~ function.

    #+begin_src c :tangle free_group_s3.h :exports none
//trexio_exit_code trexio_s3_free_read_$group$ (char* buffer, FILE* txt_file, trexio_s3_t* trexio_file, $group$_t* $group$);
trexio_exit_code trexio_s3_free_read_$group$ (char* buffer, char* txt_file, trexio_s3_t* trexio_file, $group$_t* $group$);
    #+end_src

    #+begin_src c :tangle free_group_s3.c
trexio_exit_code
//trexio_s3_free_read_$group$ (char* buffer, FILE* txt_file, trexio_s3_t* trexio_file, $group$_t* $group$)
trexio_s3_free_read_$group$ (char* buffer, char* file_buffer, trexio_s3_t* trexio_file, $group$_t* $group$)
{
  trexio_exit_code rc_free;
  if(buffer!=NULL){
	FREE(buffer);
  }
  if(file_buffer!=NULL){
	  FREE(file_buffer);
  }
  if(trexio_file==NULL) return TREXIO_INVALID_ARG_3;

  /* Set pointer to the struct so that the garbage collector can do the job on file handle */
  trexio_file->$group$ = $group$;
  rc_free = trexio_s3_free_$group$(trexio_file);
  //assert(rc_free == TREXIO_SUCCESS); est remplacé par:
  if(rc_free!=TREXIO_SUCCESS){
	fprintf(stderr, "Erreur : échec de libération des ressources (code %d)\n", rc_free);
	return TREXIO_FAILURE;
  }

  return TREXIO_SUCCESS;
}
    #+end_src

* Template for has/read/write a numerical attribute

    #+begin_src c :tangle hrw_attr_num_s3.h :exports none
trexio_exit_code trexio_s3_has_$group_num$ (trexio_t* const file);
trexio_exit_code trexio_s3_read_$group_num$ (trexio_t* const file, $group_num_dtype_double$* const num);
trexio_exit_code trexio_s3_write_$group_num$(trexio_t* const file, const $group_num_dtype_double$ num);
   #+end_src

    #+begin_src c :tangle read_attr_num_s3.c
trexio_exit_code
trexio_s3_read_$group_num$ (trexio_t* const file, $group_num_dtype_double$* const num)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (num   == NULL) return TREXIO_INVALID_ARG_2;

//  $group$_t* $group$ = trexio_s3_read_$group$((trexio_s3_t*) file);
 
  trexio_s3_t* s3_file = (trexio_s3_t*) file;
  $group$_t* $group$ = trexio_s3_read_$group$(s3_file);
  if ($group$ == NULL) return TREXIO_FAILURE;

  *num = $group$->$group_num$;

  return TREXIO_SUCCESS;

}
   #+end_src

   #+begin_src c :tangle write_attr_num_s3.c
trexio_exit_code
trexio_s3_write_$group_num$ (trexio_t* const file, const $group_num_dtype_double$ num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode == 'r') return TREXIO_READONLY;

//  $group$_t* $group$ = trexio_s3_read_$group$((trexio_s3_t*) file);
 
  trexio_s3_t* s3_file = (trexio_s3_t*) file;
  $group$_t* $group$ = trexio_s3_read_$group$(s3_file);

  if ($group$ == NULL) return TREXIO_FAILURE;

  $group$->$group_num$ = num;
  $group$->$group_num$_isSet = true;
  $group$->to_flush = 1;

  return TREXIO_SUCCESS;

}
     #+end_src

    #+begin_src c :tangle has_attr_num_s3.c
trexio_exit_code
trexio_s3_has_$group_num$ (trexio_t* const file)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;

//  $group$_t* $group$ = trexio_s3_read_$group$((trexio_s3_t*) file);

  trexio_s3_t* s3_file = (trexio_s3_t*) file;
  $group$_t* $group$ = trexio_s3_read_$group$(s3_file);
  if ($group$ == NULL) return TREXIO_FAILURE;

  if ($group$->$group_num$_isSet == true){
    return TREXIO_SUCCESS;
  } else {
    return TREXIO_HAS_NOT;
  }

}
   #+end_src

* Template for has/read/write a dataset of numerical data

     The ~group_dset~ array is assumed allocated with the appropriate size.

   #+begin_src c :tangle hrw_dset_data_s3.h :exports none
trexio_exit_code trexio_s3_has_$group_dset$ (trexio_t* const file);
trexio_exit_code trexio_s3_read_$group_dset$ (trexio_t* const file, $group_dset_dtype$* const $group_dset$, const uint32_t rank, const uint64_t* dims);
trexio_exit_code trexio_s3_write_$group_dset$(trexio_t* const file, const $group_dset_dtype$* $group_dset$, const uint32_t rank, const uint64_t* dims);
   #+end_src

   #+begin_src c :tangle read_dset_data_s3.c
trexio_exit_code
trexio_s3_read_$group_dset$ (trexio_t* const file, $group_dset_dtype$* const $group_dset$,
                               const uint32_t rank, const uint64_t* dims)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if ($group_dset$ == NULL) return TREXIO_INVALID_ARG_2;
  if (rank < 1) return TREXIO_INVALID_ARG_3;
  if (dims == NULL) return TREXIO_INVALID_ARG_4;

 // $group$_t* const $group$ = trexio_s3_read_$group$((trexio_s3_t*) file);
 
  trexio_s3_t* s3_file=(trexio_s3_t*) file;
  if(s3_file==NULL) return TREXIO_INVALID_ARG_1;

  $group$_t* const $group$ = trexio_s3_read_$group$(s3_file);
  if($group$==NULL) return TREXIO_FAILURE;
 
  if (rank != $group$->rank_$group_dset$) return TREXIO_INVALID_ARG_3;

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    if (dims[i] != $group$->dims_$group_dset$[i]) return TREXIO_INVALID_ARG_4;
    dim_size *= dims[i];
  }

  for (uint64_t i=0 ; i<dim_size ; ++i) {
    $group_dset$[i] = $group$->$group_dset$[i];
  }

  return TREXIO_SUCCESS;

}
   #+end_src

   #+begin_src c :tangle write_dset_data_s3.c
trexio_exit_code
trexio_s3_write_$group_dset$ (trexio_t* const file, const $group_dset_dtype$* $group_dset$,
                                const uint32_t rank, const uint64_t* dims)
{

  if (file  == NULL)  return TREXIO_INVALID_ARG_1;
  if ($group_dset$ == NULL)  return TREXIO_INVALID_ARG_2;
  if (rank < 1) return TREXIO_INVALID_ARG_3;
  if (dims == NULL) return TREXIO_INVALID_ARG_4;

  if (file->mode == 'r') return TREXIO_READONLY;

//  $group$_t* const $group$ = trexio_s3_read_$group$((trexio_s3_t*) file);

  trexio_s3_t* s3_file=(trexio_s3_t*) file;
  if(s3_file==NULL) return TREXIO_INVALID_ARG_1;

  $group$_t* const $group$ = trexio_s3_read_$group$(s3_file);
  if ($group$ == NULL) return TREXIO_FAILURE;

  if ($group$->$group_dset$ != NULL) {
    FREE($group$->$group_dset$);
  }

  $group$->rank_$group_dset$ = rank;

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<$group$->rank_$group_dset$; ++i){
    $group$->dims_$group_dset$[i] = dims[i];
    dim_size *= dims[i];
  }

  $group$->$group_dset$ = CALLOC(dim_size, $group_dset_dtype$);

  for (uint64_t i=0 ; i<dim_size ; ++i) {
    $group$->$group_dset$[i] = $group_dset$[i];
  }

  $group$->to_flush = 1;
  return TREXIO_SUCCESS;

}
   #+end_src

   #+begin_src c :tangle has_dset_data_s3.c
trexio_exit_code
trexio_s3_has_$group_dset$ (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  //$group$_t* const $group$ = trexio_s3_read_$group$((trexio_s3_t*) file);

  trexio_s3_t* s3_file=(trexio_s3_t*) file;
  if(s3_file==NULL) return TREXIO_INVALID_ARG_1;

  $group$_t* const $group$ = trexio_s3_read_$group$(s3_file);
  if ($group$ == NULL) return TREXIO_FAILURE;

  if ($group$->rank_$group_dset$ > 0){
    return TREXIO_SUCCESS;
  } else {
    return TREXIO_HAS_NOT;
  }

}
   #+end_src
* Template for has/read/write a dataset of strings

     The ~group_dset~ array is assumed allocated with the appropriate size.

   #+begin_src c :tangle hrw_dset_str_s3.h :exports none
trexio_exit_code trexio_s3_has_$group_dset$ (trexio_t* const file);
trexio_exit_code trexio_s3_read_$group_dset$ (trexio_t* const file, char* const dset, const uint32_t rank, const uint64_t* dims, const uint32_t max_str_len);
trexio_exit_code trexio_s3_write_$group_dset$ (trexio_t* const file, const char** dset, const uint32_t rank, const uint64_t* dims);
   #+end_src

   #+begin_src c :tangle read_dset_str_s3.c
trexio_exit_code
trexio_s3_read_$group_dset$ (trexio_t* const file, char* const dset, const uint32_t rank, const uint64_t* dims, const uint32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset == NULL) return TREXIO_INVALID_ARG_2;

//  $group$_t* const $group$ = trexio_s3_read_$group$((trexio_s3_t*) file);

  if(rank < 1) return TREXIO_INVALID_ARG_3;
  if(dims == NULL) return TREXIO_INVALID_ARG_4;

  trexio_s3_t* s3_file=(trexio_s3_t*) file;
  if(s3_file==NULL) return TREXIO_INVALID_ARG_1;

  $group$_t* const $group$ = trexio_s3_read_$group$(s3_file);
  if ($group$ == NULL) return TREXIO_FAILURE;

  if (rank != $group$->rank_$group_dset$) return TREXIO_INVALID_ARG_3;

  for (uint32_t i=0 ; i<rank ; ++i) {
    if (dims[i] != $group$->dims_$group_dset$[i]) return TREXIO_INVALID_ARG_4;
  }

  strcpy(dset, "");
  for (uint64_t i=0 ; i<dims[0] ; ++i) {
    strncat(dset, $group$->$group_dset$[i], max_str_len);
    strcat(dset, TREXIO_DELIM);
  }

  return TREXIO_SUCCESS;

}
   #+end_src

   #+begin_src c :tangle write_dset_str_s3.c
trexio_exit_code
trexio_s3_write_$group_dset$ (trexio_t* const file, const char** dset, const uint32_t rank, const uint64_t* dims)
{

  if (file  == NULL)  return TREXIO_INVALID_ARG_1;
  if (dset == NULL)  return TREXIO_INVALID_ARG_2;
  if (dims == NULL)  return TREXIO_INVALID_ARG_4;

  if (file->mode == 'r') return TREXIO_READONLY;

//  $group$_t* const $group$ = trexio_s3_read_$group$((trexio_s3_t*) file);

  trexio_s3_t* s3_file=(trexio_s3_t*) file;
  if(s3_file==NULL) return TREXIO_INVALID_ARG_1;

  $group$_t* const $group$ = trexio_s3_read_$group$(s3_file);
  if ($group$ == NULL) return TREXIO_FAILURE;

  if ($group$->$group_dset$ != NULL) {
    if ($group$->rank_$group_dset$ != 0 && $group$->$group_dset$[0] != NULL){
	 FREE($group$->$group_dset$[0]);
 	 FREE($group$->$group_dset$);
     }
  }

  $group$->rank_$group_dset$ = rank;

  for (uint32_t i=0; i<$group$->rank_$group_dset$; ++i){
    $group$->dims_$group_dset$[i] = dims[i];
  }

  $group$->$group_dset$ = CALLOC(dims[0], char*);
  if ($group$->$group_dset$ == NULL) return TREXIO_ALLOCATION_FAILED;

  char* tmp_str = CALLOC(dims[0]*32 + 1, char);
  if (tmp_str == NULL) return TREXIO_ALLOCATION_FAILED;

  for (uint64_t i=0 ; i<dims[0] ; ++i) {
//    size_t tmp_len = strlen(dset[i])+1;
//    $group$->$group_dset$[i] = tmp_str;
//    strncpy(tmp_str, dset[i], tmp_len);
//    tmp_str[tmp_len-1] = '\0';
//    tmp_str += tmp_len + 1;

       size_t tmp_len=strlen(dset[i])+1;
       $group$->$group_dset$[i]=CALLOC(tmp_len, char);
        if($group$->$group_dset$[i] == NULL){
                for(uint64_t j=0; j<i; ++j){
                        FREE($group$->$group_dset$[j]);
                }
                FREE($group$->$group_dset$);
                $group$->$group_dset$ = NULL;
                return TREXIO_ALLOCATION_FAILED;
        }
        strncpy($group$->$group_dset$[i], dset[i], tmp_len);

  }

  $group$->to_flush = 1;

  return TREXIO_SUCCESS;

}
   #+end_src

   #+begin_src c :tangle has_dset_str_s3.c
trexio_exit_code
trexio_s3_has_$group_dset$ (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

//  $group$_t* const $group$ = trexio_s3_read_$group$((trexio_s3_t*) file);

  trexio_s3_t* s3_file=(trexio_s3_t*) file;
  $group$_t* const $group$ = trexio_s3_read_$group$(s3_file);

  if ($group$ == NULL) return TREXIO_FAILURE;

  if ($group$->rank_$group_dset$ > 0 && $group$->$group_dset$ != NULL){
    return TREXIO_SUCCESS;
  } else {
    return TREXIO_HAS_NOT;
  }

}
   #+end_src
* Template for has/read/write a string attribute

   #+begin_src c :tangle hrw_attr_str_s3.h :exports none
trexio_exit_code trexio_s3_has_$group_str$ (trexio_t* const file);
trexio_exit_code trexio_s3_read_$group_str$ (trexio_t* const file, char* const str, const uint32_t max_str_len);
trexio_exit_code trexio_s3_write_$group_str$ (trexio_t* const file, const char* str);
   #+end_src

   #+begin_src c :tangle read_attr_str_s3.c
trexio_exit_code
trexio_s3_read_$group_str$ (trexio_t* const file, char* const str, const uint32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (str == NULL) return TREXIO_INVALID_ARG_2;

//  $group$_t* const $group$ = trexio_s3_read_$group$((trexio_s3_t*) file);

  trexio_s3_t* s3_file=(trexio_s3_t*) file;
  if (s3_file == NULL) return TREXIO_INVALID_ARG_1;

  $group$_t* const $group$ = trexio_s3_read_$group$(s3_file);
  if ($group$ == NULL) return TREXIO_FAILURE;

  strncpy(str, $group$->$group_str$, max_str_len);
  str[max_str_len-1] = '\0';

  return TREXIO_SUCCESS;

}
   #+end_src

   #+begin_src c :tangle write_attr_str_s3.c
trexio_exit_code
trexio_s3_write_$group_str$ (trexio_t* const file, const char *str)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str  == NULL) return TREXIO_INVALID_ARG_2;

  if (file->mode == 'r') return TREXIO_READONLY;

//  $group$_t* const $group$ = trexio_s3_read_$group$((trexio_s3_t*) file);

  trexio_s3_t* s3_file=(trexio_s3_t*) file;
  if (s3_file == NULL) return TREXIO_INVALID_ARG_1;
 
  $group$_t* const $group$ = trexio_s3_read_$group$(s3_file);
  if ($group$ == NULL) return TREXIO_FAILURE;

  if ($group$->$group_str$ != NULL) FREE($group$->$group_str$);

  size_t tmp_len = strlen(str);

  $group$->$group_str$ = CALLOC(tmp_len + 1, char);
  if ($group$->$group_str$ == NULL) return TREXIO_ALLOCATION_FAILED;

  $group$->len_$group_str$ = tmp_len + 1;

  strncpy($group$->$group_str$, str, tmp_len + 1);
  $group$->$group_str$[tmp_len] = '\0';

  $group$->to_flush = 1;

  return TREXIO_SUCCESS;

}
   #+end_src

   #+begin_src c :tangle has_attr_str_s3.c
trexio_exit_code
trexio_s3_has_$group_str$ (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  trexio_s3_t* s3_file=(trexio_s3_t*) file;
  if (s3_file == NULL) return TREXIO_INVALID_ARG_1;

  $group$_t* const $group$ = trexio_s3_read_$group$(s3_file);
  if ($group$ == NULL) return TREXIO_FAILURE;

  if ($group$->len_$group_str$ > 0){
    return TREXIO_SUCCESS;
  } else {
    return TREXIO_HAS_NOT;
  }

}
   #+end_src
* Template for has/read/write the dataset of sparse data

   Each sparse array is stored in a separate =.txt= file due to the fact that sparse I/O has to be decoupled
   from conventional write/read/flush behaviour of the TEXT back end. Chunks are used to read/write sparse data
   to prevent memory overflow. Chunks have a given ~int64_t size~
   (size specifies the number of sparse data items, e.g. integrals).

   User provides indices and values of the sparse array as two separate variables.


   #+begin_src c :tangle hrw_dset_sparse_s3.h :exports none
trexio_exit_code trexio_s3_has_$group_dset$(trexio_t* const file);
trexio_exit_code trexio_s3_read_$group_dset$(trexio_t* const file, const int64_t offset_file, const int64_t size, const int64_t size_max, int64_t* const eof_read_size, int32_t* const index_sparse, double* const value_sparse);
trexio_exit_code trexio_s3_write_$group_dset$(trexio_t* const file, const int64_t offset_file, const int64_t size, const int64_t size_max, const int64_t size_start, const int32_t* index_sparse, const double* value_sparse);
trexio_exit_code trexio_s3_read_$group_dset$_size(trexio_t* const file, int64_t* const size_max);
   #+end_src


   #+begin_src c :tangle write_dset_sparse_s3.c
trexio_exit_code trexio_s3_write_$group_dset$(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t size,
                                                const int64_t size_max,
                                                const int64_t size_start,
                                                const int32_t* index_sparse,
                                                const double* value_sparse)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
trexio_s3_t* s3_file=(trexio_s3_t*) file;
  if (s3_file == NULL) return TREXIO_INVALID_ARG_1;

  /* Build the name of the file with sparse data*/
  /* The $group_dset$.txt is limited to 256 symbols for the moment. What are the chances that it will exceed? */
  const char $group_dset$_file_name[256] = "/$group_dset$.txt";
  /* The full path to the destination TXT file with sparse data. This will include TREXIO directory name. */
  char file_full_path[TREXIO_MAX_FILENAME_LENGTH];

  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, $group_dset$_file_name,
           TREXIO_MAX_FILENAME_LENGTH-strlen($group_dset$_file_name));

  /* Open the file in "a" (append) mode to guarantee that no truncation happens upon consecutive writes */
  FILE* f = fopen(file_full_path, "a");
  if (f == NULL) return TREXIO_FILE_ERROR;

  /* Specify the line length in order to offset properly. For example, for 4-index quantities
     the line_length is 69 because 10 per index + 4 spaces + 24 for floating point value + 1 for the new line char.
     CURRENTLY NO OFFSET IS USED WHEN WRITING !
    ,*/
  (void) offset_file; // Avoid unused variable error
  
  int64_t line_length = 0L;
  char format_str[256];

  /* Determine the optimal type for storing indices depending on the size_max (usually mo_num or ao_num) */
  if (size_max < UINT8_MAX) {
    line_length = $sparse_line_length_8$; // 41 for 4 indices
    strncpy(format_str, $sparse_format_printf_8$, 256);
    format_str[255] = '\0';
  } else if (size_max < UINT16_MAX) {
    line_length = $sparse_line_length_16$; // 49 for 4 indices
    strncpy(format_str, $sparse_format_printf_16$, 256);
    format_str[255] = '\0';
  } else {
    line_length = $sparse_line_length_32$; //69 for 4 indices
    strncpy(format_str, $sparse_format_printf_32$, 256);
    format_str[255] = '\0';
  }
  strncat(format_str, "\n", 2);

  /* Get the starting position of the IO stream to be written in the .size file.
     This is error-prone due to the fact that for large files (>2 GB) in 32-bit systems ftell will fail.
     One can use ftello function which is adapted for large files.
     For now, we can use front-end-provided size_start, which has been checked for INT64_MAX overflow.
   ,*/
  int64_t io_start_pos = size_start * line_length;

  /* Write the data in the file and check the return code of fprintf to verify that > 0 bytes have been written */
  int rc;
  for (uint64_t i=0UL; i < (uint64_t) size; ++i) {
    rc = fprintf(f, format_str,
       $group_dset_sparse_indices_printf$,
       ,*(value_sparse + i));
    if (rc <= 0) {
      FREE(f);
      return TREXIO_FAILURE;
    }
  }

  /* Close the TXT file */
  rc = fclose(f);
  if (rc != 0) return TREXIO_FILE_ERROR;

  /* Append .size to the file_full_path in order to write additional info about the written buffer of data */
  strncat(file_full_path, ".size", 6);

  /* Open the new file in "a" (append) mode to append info about the buffer that has been just written */
  FILE *f_wSize = fopen(file_full_path, "a");
  if (f_wSize == NULL) return TREXIO_FILE_ERROR;

  /* Write the buffer_size */
  rc = fprintf(f_wSize, "%" PRId64 " %" PRId64 "\n", size, io_start_pos);
  if (rc <= 0) {
    fclose(f_wSize);
    return TREXIO_FAILURE;
  }

  /* Close the TXT file */
  rc = fclose(f_wSize);
  if (rc != 0) return TREXIO_FILE_ERROR;

  const char $group$_file_name[256] = "/$group$.txt";

  memset (file_full_path, 0, TREXIO_MAX_FILENAME_LENGTH);
  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, $group$_file_name,
           TREXIO_MAX_FILENAME_LENGTH-strlen($group$_file_name));

  int file_exists = s3_file_exists(s3_file->client,file_full_path, strlen(file_full_path));
  /* Create an empty file for the trexio_s3_has_group to work */
  if (file_exists!=0) {
    FILE *fp = fopen(file_full_path, "ab+");
    fclose(fp);
  }

  /* Exit upon success */
  return TREXIO_SUCCESS;
}
   #+end_src


   #+begin_src c :tangle read_dset_sparse_s3.c
trexio_exit_code trexio_s3_read_$group_dset$(trexio_t* const file,
                                               const int64_t offset_file,
                                               const int64_t size,
                                               const int64_t size_max,
                                               int64_t* const eof_read_size,
                                               int32_t* const index_sparse,
                                               double* const value_sparse)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (eof_read_size == NULL) return TREXIO_INVALID_ARG_5;

  /* Build the name of the file with sparse data.
     The $group_dset$.txt is limited to 256 symbols for the moment. What are the chances that it will exceed?
   ,*/
  const char $group_dset$_file_name[256] = "/$group_dset$.txt";
  /* The full path to the destination TXT file with sparse data. This will include TREXIO directory name. */
  char file_full_path[TREXIO_MAX_FILENAME_LENGTH];

  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, $group_dset$_file_name,
           TREXIO_MAX_FILENAME_LENGTH-strlen($group_dset$_file_name));

  /* Open the file in "r" (read) mode to guarantee that no truncation happens upon consecutive reads */
  FILE* f = fopen(file_full_path, "r");
  if (f == NULL) return TREXIO_FILE_ERROR;

  /* Specify the line length in order to offset properly. For example, for 4-index quantities
     the line_length is 69 because 10 per index + 4 spaces + 24 for floating point value + 1 for the new line char
   ,*/
  uint64_t line_length = 0UL;
  /* Determine the line length depending on the size_max (usually mo_num or ao_num) */
  if (size_max < UINT8_MAX) {
    line_length = $sparse_line_length_8$; // 41 for 4 indices
  } else if (size_max < UINT16_MAX) {
    line_length = $sparse_line_length_16$; // 49 for 4 indices
  } else {
    line_length = $sparse_line_length_32$; //69 for 4 indices
  }

  /* Offset in the file according to the provided  value of offset_file and optimal line_length */
  fseek(f, (long) offset_file * line_length, SEEK_SET);

  /* Read the data from the file and check the return code of fprintf to verify that > 0 bytes have been read or reached EOF */
  int rc;
  char buffer[1024];
  uint64_t count = 0UL;
  for (uint64_t i=0UL; i < (uint64_t) size; ++i) {

      memset(buffer, 0, sizeof(buffer));

      if (fgets(buffer, 1023, f) == NULL){

        fclose(f);
        ,*eof_read_size = count;
        return TREXIO_END;

      } else {

        rc = sscanf(buffer, "$group_dset_format_scanf$",
                    $group_dset_sparse_indices_scanf$,
                    value_sparse + i);
        if (rc <= 0) {
          fclose(f);
          return TREXIO_FAILURE;
        }
        count += 1UL;

      }
  }

  /* Close the TXT file */
  rc = fclose(f);
  if (rc != 0) return TREXIO_FILE_ERROR;

  return TREXIO_SUCCESS;
}
   #+end_src


   #+begin_src c :tangle read_dset_sparse_s3.c
trexio_exit_code trexio_s3_read_$group_dset$_size(trexio_t* const file, int64_t* const size_max)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;

  /* Build the name of the file with sparse data.
     The $group_dset$.txt is limited to 256 symbols for the moment. What are the chances that it will exceed?
   ,*/
  const char $group_dset$_file_name[256] = "/$group_dset$.txt.size";
  /* The full path to the destination TXT file with sparse data. This will include TREXIO directory name. */
  char file_full_path[TREXIO_MAX_FILENAME_LENGTH];

  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, $group_dset$_file_name,
           TREXIO_MAX_FILENAME_LENGTH-strlen($group_dset$_file_name));

  /* Open the file in "r" (read) mode to guarantee that no truncation happens upon consecutive reads */
  FILE* f = fopen(file_full_path, "r");
  if (f == NULL) return TREXIO_FILE_ERROR;


  /* Read the data from the file and check the return code of fprintf to verify that > 0 bytes have been read or reached EOF */
  int rc;
  int64_t size_item, offset_item, size_accum=0L;

  /* Read the values from the file. BEWARE OF POSSIBLE MAX_INT64 OVERFLOW ! */
  while(fscanf(f, "%" SCNd64 " %" SCNd64 "", &size_item, &offset_item) != EOF) {
    /* Check that summation will not overflow the int64_t value */
    if (INT64_MAX - size_accum > size_item) {
      size_accum += size_item;
    } else {
      fclose(f);
      ,*size_max = -1L;
      return TREXIO_INT_SIZE_OVERFLOW;
    }
  }

  /* Close the TXT file */
  rc = fclose(f);
  if (rc != 0) return TREXIO_FILE_ERROR;

  /* Overwrite the value at the input address and return TREXIO_SUCCESS */
  ,*size_max = size_accum;
  return TREXIO_SUCCESS;

}
   #+end_src

   #+begin_src c :tangle has_dset_sparse_s3.c
trexio_exit_code trexio_s3_has_$group_dset$(trexio_t* const file)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;

  /* Build the name of the file with sparse data.
     The $group_dset$.txt is limited to 256 symbols for the moment. What are the chances that it will exceed?
   ,*/
  const char $group_dset$_file_name[256] = "/$group_dset$.txt";
  /* The full path to the destination TXT file with sparse data. This will include TREXIO directory name. */
  char file_full_path[TREXIO_MAX_FILENAME_LENGTH];

  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, $group_dset$_file_name,
           TREXIO_MAX_FILENAME_LENGTH-strlen($group_dset$_file_name));

  /* Check the return code of access function to determine whether the file with sparse data exists or not */
  if (access(file_full_path, F_OK) == 0){
    return TREXIO_SUCCESS;
  } else {
    return TREXIO_HAS_NOT;
  }
}
   #+end_src

* Template for has/read/write a buffered vector

   Each array is stored in a separate =.txt= file due to the fact that buffered I/O has to be decoupled
   from conventional write/read/flush behaviour of the TEXT back end. Chunks are used to read/write the data
   to prevent memory overflow. Chunks have a given ~int64_t size~.
   Size specifies the number of vector elements to be written.

   #+begin_src c :tangle hrw_buffered_s3.h :exports none
trexio_exit_code trexio_s3_has_$group_dset$(trexio_t* const file);
trexio_exit_code trexio_s3_read_$group_dset$(trexio_t* const file, const int64_t offset_file, const uint32_t rank, const uint64_t* dims, int64_t* const eof_read_size, double* const dset);
trexio_exit_code trexio_s3_write_$group_dset$(trexio_t* const file, const int64_t offset_file, const uint32_t rank, const uint64_t* dims, const double* dset);
trexio_exit_code trexio_s3_read_$group_dset$_size(trexio_t* const file, int64_t* const size_max);
   #+end_src

   #+begin_src c :tangle read_buffered_s3.c
trexio_exit_code trexio_s3_read_$group_dset$(trexio_t* const file,
                                               const int64_t offset_file,
                                               const uint32_t rank,
                                               const uint64_t* dims,
                                               int64_t* const eof_read_size,
                                               double* const dset)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0) return TREXIO_INVALID_ARG_2;
  if (rank < 1) return TREXIO_INVALID_ARG_3;
  if (dims == NULL) return TREXIO_INVALID_ARG_4;
  if (eof_read_size == NULL) return TREXIO_INVALID_ARG_5;
  if (dset == NULL) return TREXIO_INVALID_ARG_6;

  const char file_name[256] = "/$group_dset$.txt";

  /* The full path to the destination TXT file with sparse data. This will include TREXIO directory name. */
  char file_full_path[TREXIO_MAX_FILENAME_LENGTH];
  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, file_name, TREXIO_MAX_FILENAME_LENGTH - sizeof(file_name));

  /* Open the file in "r" (read) mode to guarantee that no truncation happens upon consecutive reads */
  FILE* f = fopen(file_full_path, "r");
  if (f == NULL) return TREXIO_FILE_ERROR;

  /* Specify the line length in order to offset properly.
     Each double value 24 elements + one newline char.
   ,*/
  uint64_t line_length = 25UL;

  /* Offset in the file according to the provided  value of offset_file and optimal line_length */
  fseek(f, (long) offset_file * line_length, SEEK_SET);

  /* Read the data from the file and check the return code of fprintf to verify that > 0 bytes have been read or reached EOF */
  int rc;
  char buffer[64];
  uint32_t buf_size = sizeof(buffer);
  /* Counter for number of elements beind processed */
  uint64_t count = 0UL;

  for (uint64_t i=0UL; i < dims[0]; ++i) {

    memset(buffer, 0, buf_size);
    if (fgets(buffer, buf_size-1, f) == NULL){

      fclose(f);
      ,*eof_read_size = count;
      return TREXIO_END;

    } else {

      rc = sscanf(buffer, "%lf", dset + i);
      if (rc <= 0) {
        fclose(f);
        return TREXIO_FAILURE;
      }
      count += 1UL;

    }
  }

  /* Close the TXT file */
  rc = fclose(f);
  if (rc != 0) return TREXIO_FILE_ERROR;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_s3_read_$group_dset$_size(trexio_t* const file, int64_t* const size_max)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;

  const char file_name[256] = "/$group_dset$.txt.size";

  /* The full path to the destination TXT file with sparse data. This will include TREXIO directory name. */
  char file_full_path[TREXIO_MAX_FILENAME_LENGTH];
  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, file_name, TREXIO_MAX_FILENAME_LENGTH - sizeof(file_name));

  /* Open the file in "r" (read) mode to guarantee that no truncation happens upon consecutive reads */
  FILE* f = fopen(file_full_path, "r");
  if (f == NULL) return TREXIO_FILE_ERROR;

  /* Read the data from the file and check the return code of fprintf to verify that > 0 bytes have been read or reached EOF */
  int rc;
  int64_t size_item, size_accum=0L;

  /* Read the values from the file. BEWARE OF POSSIBLE MAX_INT64 OVERFLOW ! */
  while(fscanf(f, "%" SCNd64, &size_item) != EOF) {
    /* Check that summation will not overflow the int64_t value */
    if (INT64_MAX - size_accum > size_item) {
      size_accum += size_item;
    } else {
      fclose(f);
      ,*size_max = -1L;
      return TREXIO_INT_SIZE_OVERFLOW;
    }
  }

  /* Close the TXT file */
  rc = fclose(f);
  if (rc != 0) return TREXIO_FILE_ERROR;

  /* Overwrite the value at the input address and return TREXIO_SUCCESS */
  ,*size_max = size_accum;
  return TREXIO_SUCCESS;
}
   #+end_src

   #+begin_src c :tangle write_buffered_s3.c
trexio_exit_code trexio_s3_write_$group_dset$(trexio_t* const file,
                                                const int64_t offset_file,
                                                const uint32_t rank,
                                                const uint64_t* dims,
                                                const double* dset)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0) return TREXIO_INVALID_ARG_2;
  if (rank < 1) return TREXIO_INVALID_ARG_3;
  if (dims == NULL) return TREXIO_INVALID_ARG_4;
  if (dset == NULL) return TREXIO_INVALID_ARG_5;

  const char file_name[256] = "/$group_dset$.txt";
  const int append_str_len = 6;

  /* The full path to the destination TXT file with sparse data. This will include TREXIO directory name. */
  char file_full_path[TREXIO_MAX_FILENAME_LENGTH];
  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, file_name, TREXIO_MAX_FILENAME_LENGTH - sizeof(file_name));

  /* Open the file in "a" (append) mode to guarantee that no truncation happens upon consecutive writes */
  FILE* f = fopen(file_full_path, "a");
  if (f == NULL) return TREXIO_FILE_ERROR;

  /* Write the data in the file and check the return code of fprintf to verify that > 0 bytes have been written */
  int rc;
  for (uint64_t i=0UL; i < dims[0]; ++i) {

    rc = fprintf(f, "%24.16e\n", *(dset+ i));
    if (rc <= 0) {
      fclose(f);
      return TREXIO_FAILURE;
    }

  }

  /* Close the TXT file */
  rc = fclose(f);
  if (rc != 0) return TREXIO_FILE_ERROR;

  /* Append .size to the file_full_path in order to write additional info about the written buffer of data */
  strncat(file_full_path, ".size", append_str_len);

  /* Open the new file in "a" (append) mode to append info about the buffer that has been just written */
  FILE *f_wSize = fopen(file_full_path, "a");
  if (f_wSize == NULL) return TREXIO_FILE_ERROR;

  /* Write the buffer_size */
  rc = fprintf(f_wSize, "%" PRIu64 "\n", dims[0]);
  if (rc <= 0) {
    fclose(f_wSize);
    return TREXIO_FAILURE;
  }

  /* Close the TXT file */
  rc = fclose(f_wSize);
  if (rc != 0) return TREXIO_FILE_ERROR;

  /* Additional part for the trexio_s3_has_group to work */
  const char group_file_name[256] = "/$group$.txt";

  memset (file_full_path, 0, TREXIO_MAX_FILENAME_LENGTH);
  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, group_file_name, TREXIO_MAX_FILENAME_LENGTH - sizeof(group_file_name));
  trexio_s3_t* const s3_file = (trexio_s3_t*) file;
  int file_exists = s3_file_exists(s3_file->client, file_full_path, strlen(file_full_path));

  /* Create an empty file for the trexio_s3_has_group to work */
  if (file_exists!=0) {
    FILE *fp = fopen(file_full_path, "ab+");
    fclose(fp);
  }

  /* Exit upon success */
  return TREXIO_SUCCESS;
}

   #+end_src

   #+begin_src c :tangle has_buffered_s3.c
trexio_exit_code trexio_s3_has_$group_dset$(trexio_t* const file)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;

  const char file_name[256] = "/$group_dset$.txt";

  /* The full path to the destination TXT file with sparse data. This will include TREXIO directory name. */
  char file_full_path[TREXIO_MAX_FILENAME_LENGTH];
  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, file_name, TREXIO_MAX_FILENAME_LENGTH - sizeof(file_name));

  /* Check the return code of access function to determine whether the file with data exists or not */
  if (access(file_full_path, F_OK) == 0){
    return TREXIO_SUCCESS;
  } else {
    return TREXIO_HAS_NOT;
  }
}
   #+end_src
* Template for text delete a group (UNSAFE mode)

  #+begin_src c :tangle delete_group_s3.h :exports none
trexio_exit_code trexio_s3_delete_$group$ (trexio_t* const file);
  #+end_src

  #+begin_src c :tangle delete_group_s3.c
trexio_exit_code
trexio_s3_delete_$group$ (trexio_t* const file)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;

  trexio_s3_t* f = (trexio_s3_t*) file;

  $group$_t* $group$ = trexio_s3_read_$group$(f);
  if ($group$ == NULL) return TREXIO_FAILURE;

  int rc = remove($group$->file_name);
  if (rc == -1) return TREXIO_FAILURE;

  $group$->to_flush = 0;

  trexio_exit_code rc_free = trexio_s3_free_$group$(f);
  if (rc_free != TREXIO_SUCCESS) return rc_free;

  return TREXIO_SUCCESS;
}
   #+end_src

* Source code for the determinant part

   Each array is stored in a separate =.txt= file due to the fact that determinant I/O has to be decoupled
   from conventional write/read/flush behaviour of the TEXT back end. Chunks are used to read/write the data
   to prevent memory overflow. Chunks have a given ~int64_t size~.
   Size specifies the number of data items, e.g. determinants.


   #+begin_src c :tangle hrw_determinant_s3.h :exports none
trexio_exit_code trexio_s3_has_determinant_list(trexio_t* const file);
trexio_exit_code trexio_s3_read_determinant_list(trexio_t* const file, const int64_t offset_file, const uint32_t rank, const uint64_t* dims, int64_t* const eof_read_size, int64_t* const list);
trexio_exit_code trexio_s3_write_determinant_list(trexio_t* const file, const int64_t offset_file, const uint32_t rank, const uint64_t* dims, const int64_t* list);
   #+end_src

   #+begin_src c :tangle read_determinant_s3.c
trexio_exit_code trexio_s3_read_determinant_list(trexio_t* const file,
                                                   const int64_t offset_file,
                                                   const uint32_t rank,
                                                   const uint64_t* dims,
                                                   int64_t* const eof_read_size,
                                                   int64_t* const list)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0) return TREXIO_INVALID_ARG_2;
  if (rank != 2) return TREXIO_INVALID_ARG_3;
  if (dims == NULL) return TREXIO_INVALID_ARG_4;
  if (eof_read_size == NULL) return TREXIO_INVALID_ARG_5;
  if (list == NULL) return TREXIO_INVALID_ARG_6;

  const char determinant_list_file_name[256] = "/determinant_list.txt";
  /* The full path to the destination TXT file with sparse data. This will include TREXIO directory name. */
  char file_full_path[TREXIO_MAX_FILENAME_LENGTH];

  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, determinant_list_file_name,
           TREXIO_MAX_FILENAME_LENGTH-strlen(determinant_list_file_name));

  /* Open the file in "r" (read) mode to guarantee that no truncation happens upon consecutive reads */
  FILE* f = fopen(file_full_path, "r");
  if (f == NULL) return TREXIO_FILE_ERROR;

  /* Specify the line length in order to offset properly.
     Each 64-bit integer takes 20 slots and requires one space,

     we have int_num integers per up-spin determinant,
     then this number is doubled because we have the same number for down-spin electrons,
     and then one newline char.
   ,*/
  uint64_t line_length = dims[1]*21UL + 1UL; // 20 digits per int64_t bitfield + 1 space = 21 spots + 1 newline char

  /* Offset in the file according to the provided  value of offset_file and optimal line_length */
  fseek(f, (long) offset_file * line_length, SEEK_SET);

  /* Read the data from the file and check the return code of fprintf to verify that > 0 bytes have been read or reached EOF */
  int rc;
  /* Declare fixed buffer which will be used to read the determinant string <a1 a2 ... a/\ b1 b2 ... b\/> */
  char buffer[line_length+1];
  size_t buf_size = sizeof(buffer);
  /* Parameters to post-process the buffer and to get bit fields integers */
  uint64_t accum = 0UL;
  uint32_t shift_int64 = 21U;
  /* Counter for number of elements beind processed */
  uint64_t count = 0UL;
  for (uint64_t i=0UL; i < dims[0]; ++i) {

    accum = 0UL;
    memset(buffer, 0, buf_size);

    if (fgets(buffer, ( (int) line_length)+1, f) == NULL){

      fclose(f);
      ,*eof_read_size = count;
      return TREXIO_END;

    } else {

   /* The format string is not anymore static but rather dynamic (the number of ints depend on the mo_num)
      Thus, we parse the buffer string int_num*2 times to get the bit field determinants.
    ,*/
      for (uint32_t j=0; j < (uint32_t) dims[1]; ++j) {
        rc = sscanf(buffer+accum, "%20" SCNd64, list + dims[1]*i + j);
        if (rc <= 0) {
          fclose(f);
          return TREXIO_FAILURE;
        }
        accum += shift_int64;
      }
      count += 1UL;

    }
  }

  /* Close the TXT file */
  rc = fclose(f);
  if (rc != 0) return TREXIO_FILE_ERROR;

  return TREXIO_SUCCESS;
}
   #+end_src

   #+begin_src c :tangle write_determinant_s3.c
trexio_exit_code trexio_s3_write_determinant_list(trexio_t* const file,
                                                    const int64_t offset_file,
                                                    const uint32_t rank,
                                                    const uint64_t* dims,
                                                    const int64_t* list)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0) return TREXIO_INVALID_ARG_2;
  if (rank != 2) return TREXIO_INVALID_ARG_3;
  if (dims == NULL) return TREXIO_INVALID_ARG_4;
  if (list == NULL) return TREXIO_INVALID_ARG_5;

  const char determinant_list_file_name[256] = "/determinant_list.txt";
  /* The full path to the destination TXT file with sparse data. This will include TREXIO directory name. */
  char file_full_path[TREXIO_MAX_FILENAME_LENGTH];

  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, determinant_list_file_name,
           TREXIO_MAX_FILENAME_LENGTH-strlen(determinant_list_file_name));

  /* Open the file in "a" (append) mode to guarantee that no truncation happens upon consecutive writes */
  FILE* f = fopen(file_full_path, "a");
  if (f == NULL) return TREXIO_FILE_ERROR;

  /* Write the data in the file and check the return code of fprintf to verify that > 0 bytes have been written */
  int rc;
  for (uint64_t i=0UL; i < dims[0]; ++i) {

    /* The loop below is needed to write a line with int bit fields for alpha and beta electrons */
    for (uint32_t j=0; j < (uint32_t) dims[1]; ++j) {
      rc = fprintf(f, "%20" PRId64 " ", *(list + i*dims[1] + j));
      if (rc <= 0) {
        fclose(f);
        return TREXIO_FAILURE;
      }
    }
    fprintf(f, "%s", "\n");

  }

  /* Close the TXT file */
  rc = fclose(f);
  if (rc != 0) return TREXIO_FILE_ERROR;

  /* Additional part for the trexio_s3_has_group to work */
  const char det_file_name[256] = "/determinant.txt";

  memset (file_full_path, 0, TREXIO_MAX_FILENAME_LENGTH);
  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, det_file_name,
           TREXIO_MAX_FILENAME_LENGTH-strlen(det_file_name));

   trexio_s3_t* const s3_file = (trexio_s3_t*) file;
   void* client = s3_file->client;
   int file_exists = s3_file_exists(client, file_full_path, strlen(file_full_path));

  /* Create an empty file for the trexio_s3_has_group to work */
  if (file_exists!=0) {
    FILE *fp = fopen(file_full_path, "ab+");
    fclose(fp);
  }

  /* Exit upon success */
  return TREXIO_SUCCESS;
}
   #+end_src

   #+begin_src c :tangle has_determinant_s3.c
trexio_exit_code trexio_s3_has_determinant_list(trexio_t* const file)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;

  const char determinant_list_file_name[256] = "/determinant_list.txt";
  /* The full path to the destination TXT file with sparse data. This will include TREXIO directory name. */
  char file_full_path[TREXIO_MAX_FILENAME_LENGTH];

  /* Copy directory name in file_full_path */
  strncpy (file_full_path, file->file_name, TREXIO_MAX_FILENAME_LENGTH);
  file_full_path[TREXIO_MAX_FILENAME_LENGTH-1] = '\0';
  /* Append name of the file with sparse data */
  strncat (file_full_path, determinant_list_file_name,
           TREXIO_MAX_FILENAME_LENGTH-strlen(determinant_list_file_name));

  /* Check the return code of access function to determine whether the file with data exists or not */
  if (access(file_full_path, F_OK) == 0){
    return TREXIO_SUCCESS;
  } else {
    return TREXIO_HAS_NOT;
  }
}
   #+end_src

* Constant file suffixes (not used by the generator)               :noexport:

  #+begin_src c :tangle suffix_s3.h
#endif
  #+end_src
